<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>实现一个更严格的伪数组对象</title>
</head>
<body>
</body>
<script>
    // 无陷阱实现代理
    // let target={};
    // let proxy=new Proxy(target,{});
    // proxy[0]={};
    // console.log(proxy[0]===target[0]);
    // console.log(proxy.length);
    // console.log(proxy);

    // 使用set陷阱设置输入的值的类型
    // let target=[];
    // let proxy=new Proxy(target,{
    //     set(trapTarget,key,value,recevier){
    //         console.log(recevier===proxy);//true，代理对象
    //         console.log("key="+key);
    //         console.log("value="+value);
    //         console.log("recevier");
    //         console.log(recevier);
    //         if(!trapTarget.hasOwnProperty(key))
    //         {
    //             if(isNaN(value)){
    //                 throw new TypeError("属性值必须是数字");
    //             }
    //         }
    //         //默认特性，修改值
    //        return Reflect.set(trapTarget,key,value,recevier); 
    //     }
    // });
    // proxy.push(1,2);
    // proxy.push(3);

    // 使用get()陷阱，解决不能访问不存在的属性
    // let arr=[1,2,3];
    // let proxy=new Proxy(arr,{
    //     get(trapTarget,key,receiver)
    //     {
    //         console.log(receiver);
    //         if(!(key in receiver))
    //         {
    //             console.log(key);
    //             throw new TypeError("属性"+key+"不存在");
    //         }
    //         return Reflect.get(trapTarget,key,receiver);
    //     }
    // });
    // console.log(proxy.length);
    // console.log(proxy[3]);//出错。访问不存在的属性

    // 使用has陷阱隐藏已有属性
    // let target=[1];
    // console.log("0" in target);//true
    // let proxy=new Proxy(target,{
    //     has(target,key,recevier){
    //         console.log("进入has方法");
    //         if(key==="length")
    //             return false;
    //         if(key==="0")
    //             return false;
    //         return Reflect.has(target,key,recevier);

    //     },
    //     get(trapTarget,key,receiver)
    //     {
    //         console.log(receiver);
    //         if(!(key in receiver))//调用has
    //         {
    //             console.log(key);
    //             throw new TypeError("属性"+key+"不存在");
    //         }
    //         return Reflect.get(trapTarget,key,receiver);
    //     }
    // });
    // // console.log("length" in proxy);//出错,proxy can't report a non-configurable own property '"length"' as non-existent;不能够设置一个不可配置属性为不存在
    // console.log(proxy[0]);

    // 使用deleteProperty陷阱防止删除属性
    // "use strict";
    // let target=[1,1];
    // console.log(delete target[0]);//true
    // let proxy=new Proxy(target,{
    //     deleteProperty(tragTarget,key){
    //         if(key==="1")
    //             return false;
    //         else
    //             return Reflect.deleteProperty(tragTarget,key);
    //     }
    // });
    // console.log(delete proxy[1]);//false

    // getPropertypeOf()与setPropertypeOf()陷阱可以拦截Object.getPropertypeOf()和Object.setPropertypeOf()
    // let target={1:2};
    // function fun1(a){
    //     this.a=a
    // }
    // let fun=new fun1(2);
    // console.log(Object.getPrototypeOf(fun));



</script>
</html>